<!DOCTYPE html><html lang="en"><head>
  <meta charset="utf-8">
  <title>Maciej Treder</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="assets/icons/favicon.ico">

  <link rel="preload" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,300" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"></noscript>
  <script defer="" src="https://www.googletagmanager.com/gtag/js?id=UA-109145893-3"></script>
  <script defer="">
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-109145893-3');
  </script>
<link rel="stylesheet" href="styles.37700fd2c994487ae987.css"><style ng-transition="serverApp">[_nghost-sc22]{flex:1 0 auto;display:flex;flex-direction:column;width:1200px}@media screen and (max-width:1240px){[_nghost-sc22]{width:100%}}[_nghost-sc22] > *[_ngcontent-sc22]{padding:0 20px}div.outer[_ngcontent-sc22]{position:fixed;padding:0;bottom:0;width:inherit;height:64px;display:flex;flex-direction:row-reverse;z-index:-1}div.outer[_ngcontent-sc22]   span[_ngcontent-sc22]{opacity:0;width:60px;height:60px;background:#efefef url(arrow.1606ec0177601d36c44d.png);background-size:cover;box-shadow:1px 1px 10px #ccc;border-radius:60px;display:block;position:relative;bottom:10px;right:-64px}@media screen and (max-width:1350px){div.outer[_ngcontent-sc22]   span[_ngcontent-sc22]{right:20px}}div.outer[_ngcontent-sc22]   span[_ngcontent-sc22]:hover{cursor:pointer}</style><style ng-transition="serverApp">[_nghost-sc16]{display:flex;flex-direction:column;align-items:left}h1[_ngcontent-sc16], h2[_ngcontent-sc16]{line-height:0;padding:20px 0}h1[_ngcontent-sc16]   strong[_ngcontent-sc16], h2[_ngcontent-sc16]   strong[_ngcontent-sc16]{font-weight:400!important}h1[_ngcontent-sc16]{font-size:1.5em}.navigation[_ngcontent-sc16]{display:flex;flex-direction:row;text-align:center;align-items:center}.navigation[_ngcontent-sc16]   a[_ngcontent-sc16]{font-size:1.5em}.navigation[_ngcontent-sc16]   a[_ngcontent-sc16] + a[_ngcontent-sc16]{margin-left:20px}.navigation[_ngcontent-sc16]   a.active[_ngcontent-sc16]{font-size:2em}.navigation[_ngcontent-sc16]   a.active[_ngcontent-sc16]:hover{cursor:default;color:#777}@media only screen and (max-width:330px){.navigation[_ngcontent-sc16]   a[_ngcontent-sc16]{font-size:1.2em}.navigation[_ngcontent-sc16]   a.active[_ngcontent-sc16]{font-size:1.5em}}</style><style ng-transition="serverApp">[_nghost-sc21]{justify-content:center;flex-direction:column;font-size:16px}.contact-info[_ngcontent-sc21], [_nghost-sc21]{display:flex;align-items:center}.contact-info[_ngcontent-sc21]{flex-direction:row;justify-content:flex-start;width:450px}.instructions[_ngcontent-sc21]{display:block;font-size:.7em;color:#999}.social[_ngcontent-sc21]{display:flex;flex-direction:row;justify-content:center;align-items:center;flex-wrap:wrap}.social[_ngcontent-sc21]   a[_ngcontent-sc21]{width:50px;height:50px;display:block;text-decoration:none;margin-top:10px}.gitlab[_ngcontent-sc21]{background:url(gitlab_hover.8ed9def95dcfb89161d4.png) no-repeat 50%!important}.skype[_ngcontent-sc21]{background:url(skype_hover.790010d3792393e3f6c7.png) no-repeat 50%!important}.linkedin[_ngcontent-sc21]{background:url(linkedin_hover.7737ba13e985f3b7e421.png) no-repeat 50%!important}.github[_ngcontent-sc21]{background:url(github_hover.4e53ba0592a9aac9ab61.png) no-repeat 50%!important}.mail[_ngcontent-sc21]{background:url(mail_hover.08ece0002378c99acc0d.png) no-repeat 50%!important}.phone[_ngcontent-sc21]{background:url(phone_hover.0b7eb66c2d8f6b33244a.png) no-repeat 50%!important}.twitter[_ngcontent-sc21]{background:url(twitter_hover.1763d90621379b4326be.png) no-repeat 50%!important}.stackoverflow[_ngcontent-sc21]{background:url(stackoverflow_hover.b4b5315840ad3d073fc4.png) no-repeat 50%!important}.npm[_ngcontent-sc21]{background:url(npm_hover.c687e618fdd211a84a3d.png) no-repeat 50%}@media only screen and (max-width:450px){.contact-info[_ngcontent-sc21], .social[_ngcontent-sc21], [_nghost-sc21]{width:350px}}@media only screen and (max-width:350px){.contact-info[_ngcontent-sc21], .social[_ngcontent-sc21], [_nghost-sc21]{width:300px;flex-wrap:wrap}}@media only screen and (max-width:300px){.contact-info[_ngcontent-sc21], .social[_ngcontent-sc21], [_nghost-sc21]{width:280px;flex-wrap:wrap}}</style><style ng-transition="serverApp">[_nghost-sc20]{flex:1;justify-content:center;align-items:center;display:flex;flex-direction:column;padding:5em 0}</style><style ng-transition="serverApp">a[_ngcontent-sc20]:hover   .title[_ngcontent-sc20]{text-decoration:underline}</style></head>
<body>
  <app-root _nghost-sc22="" class="ng-tns-c22-0" ng-version="10.0.14"><app-header _ngcontent-sc22="" id="header" class="ng-tns-c22-0" _nghost-sc16=""><div _ngcontent-sc16="" class="title ng-star-inserted"><h1 _ngcontent-sc16=""><strong _ngcontent-sc16="">maciej</strong>treder</h1></div><!----><!----></app-header><div _ngcontent-sc22="" id="content-wrapper" class="ng-tns-c22-0"><router-outlet _ngcontent-sc22="" class="ng-tns-c22-0"></router-outlet><app-writing _nghost-sc20="" class="ng-star-inserted"><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-choosing-the-right-asynchronous-tool"><div _ngcontent-sc20="" class="date">Aug 27, 2020 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Choosing the Right Asynchronous Tool</h3><div _ngcontent-sc20="" class="description"><p>Since its beginning as a primitive, unstandardized scripting language for web browsers, JavaScript has gained many features that better equip it for handling common programming tasks. Some of the most important improvements are in the area of handling asynchronous events like form submission, user interface interaction, and media management.</p><p>The growth of server-side JavaScript enabled by Node.js has substantially expanded the range of project types and business challenges JavaScript can successfully address, adding new requirements for asynchronous processing. The popularity of web services as a design paradigm and REST APIs as an interaction standard have both added to the scope of asynchronous tasks for the language.</p><p>The Node package management system, npm, makes it possible to easily integrate capabilities provided in open source libraries. Packages for asynchronous tasks have been some of the most successful of these, adding programming paradigms to JavaScript that were unimagined in the early days of...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-using-promises-rest-apis-nodejs"><div _ngcontent-sc20="" class="date">Jul 30, 2020 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Using Promises With REST APIs in Node.js</h3><div _ngcontent-sc20="" class="description"><p>In JavaScript, like many programming languages, asynchronous processing can be used to handle tasks that take a long time to run or are potentially unresponsive. The JavaScript Promise object provides a way of monitoring their state and serves as a placeholder and container for the data they’ll eventually return — or not.</p><p>Often it doesn’t matter when a Promise returns data and the members of a collection of Promises can be resolved independently without regard to timing. A function can perform asynchronous tasks that don’t depend on the data from, or the success of, other asynchronous tasks.</p><p>But sometimes business rules or program design require that asynchronous actions are dependent on other asynchronous operations. For example...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-introducing-async-and-await"><div _ngcontent-sc20="" class="date">Jul 1, 2020 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Introducing async and await</h3><div _ngcontent-sc20="" class="description"><p>Asynchronous processing is one of the most important aspects of the JavaScript language. JavaScript is a single-threaded language, so it needs a mechanism to deal with the actions like performing time-intensive and potentially unreliable activities like making REST API calls, reading files from the disk, or interacting with user input.</p><p>In JavaScript the mechanism used is an event loop, which processes a callback queue in order from oldest item to newest. Each item in the queue is a message that’s processed completely before moving on to the next next message. Each message is a function that returns a response to code elsewhere in the application. Functions used in this way are called callback functions.</p><p>Because of callbacks, JavaScript can use a number of techniques for getting around its single-threaded nature to implement asynchronous processing. Unfortunately, some of those techniques, JavaScript Promises and RxJS Observables, force you to introduce at...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/real-time-event-notifications-using-node-js-rxjs-observables-twilio-programmable-sms"><div _ngcontent-sc20="" class="date">May 22, 2020 | for Twilio</div><h3 _ngcontent-sc20="">Tracking the ISS with Real-Time Event Notifications Using Node.js, RxJS Observables, and Twilio Programmable SMS</h3><div _ngcontent-sc20="" class="description"><p>Are you a developer looking for a new hobby that’s compatible with sheltering in place? Would you like to be able to share it with friends from a virus-safe distance?</p><p>You can stargaze from the safety of your own lawn, balcony, or roof, and you don’t need any equipment other than your own eyes, and maybe a pair of binoculars. There are plenty of bright objects in the night sky that are visible with the naked eye. One of them is the International Space Station (ISS), which is the third brightest object in the sky after the sun and moon.</p><p>The ISS whips around the earth at 27,576 kilometers per hour (17,000 miles per hour), making a complete orbit every 94 minutes. Opportunities to observe it only last a few minutes, so it’s helpful to know when the ISS will be visible and from which direction it will appear.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#rxjs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/confirming-sms-message-delivery-with-rxjs-observables-node-js-and-twilio-programmable-sms"><div _ngcontent-sc20="" class="date">Apr 9, 2020 | for Twilio</div><h3 _ngcontent-sc20="">Confirming SMS Message Delivery with RxJS Observables, Node.js, and Twilio Programmable SMS</h3><div _ngcontent-sc20="" class="description"><p>SMS messages can reach over 4.5 billion text-enabled devices to notify people about upcoming appointments, emergencies, traffic disruptions, or commercial promotions. Sending SMS messages programmatically enables you to reach many people almost simultaneously. With Twilio Programmable SMS you can create a Node.js application that sends many messages and reports when each of them has been delivered—or not.</p><p>Twilio Programmable SMS includes a helper library for Node.js that makes it easy to interact with the SMS API without having to create and manipulate connections to the API endpoints. Once an SMS message request is created with the helper library its status is emitted as a JavaScript Promise. While that is great for creating a request asynchronously, Promises only resolve once, and the message request will pass through more than one state as it makes its way—or not—to the recipient.</p><p>You can create a mechanism for monitoring and reporting the status...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#rxjs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/async-js-rxjs-observables-rest-api-nodejs"><div _ngcontent-sc20="" class="date">Jan 27, 2020 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Using RxJS Observables with REST APIs in Node.js</h3><div _ngcontent-sc20="" class="description"><p>ReactiveX is an electrifying programming concept. It’s widely adopted in popular programming languages, including JavaScript. ReactiveX programs can react to data as it is emitted from a source, rather than get the data from it. This is a convenient way of handling data from sources like web APIs or WebSockets.</p><p>In this post you’ll get hands-on experience doing ReactiveX programming with RxJS: ReactiveX for JavaScript. You’ll learn how to perform REST API calls to retrieve data asynchronously, manipulate it as it arrives, and perform subsequent calls based on the emitted data. You’ll also see how to perform other actions whenever data is emitted by an Observable.</p><p>This post focuses on how to utilize RxJS Observables with REST API calls...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#rxjs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-reactivex-rxjs-observables-nodejs"><div _ngcontent-sc20="" class="date">Oct 31, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Introducing ReactiveX and RxJS Observables</h3><div _ngcontent-sc20="" class="description"><p>Reactive Extensions (ReactiveX) are one of the most widely-adopted set of tools in programming today. ReactiveX libraries for JavaScript and other languages provide a way to operate on sequences of data as if they were events. This is a convenient way to handle data from asynchronous sources like web APIs: your programs can react to data as it is emitted from the source without tightly coupling the code that uses the data with the code that gets the data.</p><p>In this post you’ll learn about the fundamental concepts of ReactiveX programming and get hands-on experience doing ReactiveX programming with RxJS for JavaScript. You’ll learn how to retrieve data asynchronously, manipulate it as it arrives, and handle errors. You’ll also see how RxJS Observables compare to JavaScript Promises.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#rxjs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-refactor-callbacks-promises-node-js"><div _ngcontent-sc20="" class="date">Oct 14, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Refactoring Callbacks to Promises in Node.js</h3><div _ngcontent-sc20="" class="description"><p>If you know how the event loop mechanism works in JavaScript you know how it enables you to work with asynchronous events. You might also know how to refactor your code into separate functions to reduce the amount of nesting associated with a sequence of callback functions. If you work with web APIs you are probably familiar with the JavaScript request library, which is used to perform HTTP calls.</p><p>You can put these skills together to retrieve remote data through an HTTP request and work with the call response asynchronously. But in doing so you’ll probably notice that code has at least one pitfall: the logical order of declared functions is reversed. That makes the code hard to read and maintain.</p><p>With the node-fetch JavaScript library and Promise objects you can reduce nesting, known as the callback “Pyramid of Doom”, and organize your code in a more readable and logical</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#rxjs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-advanced-promises-chaining-collections-nodejs"><div _ngcontent-sc20="" class="date">Oct 10, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Advanced Promises with Node.js</h3><div _ngcontent-sc20="" class="description"><p>JavaScript Promise objects are a considerable improvement over basic JavaScript callback functions. Promises provide an object that represents both the state of an asynchronous function and the values returned by it. The state indicates whether the promise is pending, fulfilled by a successfully completed operation, or rejected because of an error or other condition. When a promise is fulfilled its value is determined by the asynchronous operation executed by the promise.</p><p>Promises can also be chained together to use the state of settled promises (resolved or rejected) and the promises’ values to control the flow of execution in your program. This is useful when you have a sequence of asynchronous operations to perform that each depend on the results of the previous operation: the next step in the chain isn’t performed until the preceding step is resolved. Chains of promises also include error propagation; errors in a...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#promises</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-introduction-promises"><div _ngcontent-sc20="" class="date">Aug 31, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Introduction to JavaScript Promises</h3><div _ngcontent-sc20="" class="description"><p>Asynchronous processing is one of the most important capabilities JavaScript acquired as the language matured. JavaScript’s async capabilities enable more sophisticated and responsive user interfaces. They also make it possible to implement a distributed web application architecture built on standards like SOAP and REST.</p><p>JavaScript Promises are currently the most powerful and flexible asynchronous technology built into the language itself. This post will explain how they work and get you writing your own promises with some practical examples.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#promises</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-organize-callbacks-readability-reusability"><div _ngcontent-sc20="" class="date">Jun 28, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Organizing Callbacks for Readability and Reusability</h3><div _ngcontent-sc20="" class="description"><p>Asynchronous programming is an essential part of being a complete JavaScript programmer. Understanding the code execution flow in JavaScript is the foundation of understanding how it can handle asynchronous tasks. And being able to program asynchronous tasks enables you to take advantage of the extensive array of functions provided by JavaScript runtime engines and external APIs. With those tools you can connect your JavaScript programs with web APIs across the internet and effectively manage those—sometimes tenuous—connections.</p><p>With power comes complexity. Using JavaScript callbacks to implement asynchronous functionality can quickly create a series of deeply nested function calls. This post will show you how to write and organize your JavaScript callbacks to maximize the readability, maintainability, and reusability of your asynchronous functions.</p><p>As an old programming saying goes:</p><p>"Any fool can write code that a computer can understand. Good programmers write code that humans can understand."</p><p>The first part of this...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#callbacks</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/asynchronous-javascript-understanding-callbacks"><div _ngcontent-sc20="" class="date">Jun 28, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Asynchronous JavaScript: Understanding Callbacks</h3><div _ngcontent-sc20="" class="description"><p>By design, JavaScript is a synchronous scripting language. In fact, many of the widely used asynchronous functions in JavaScript are not part of the core language. Understanding how asynchronous features work in the JavaScript ecosystem, including the role played by external APIs, is an essential part of using the language effectively.</p><p>This post will show you how to use asynchronous functionality in JavaScript. It’s also going to explain an important difference between the way code execution works in JavaScript and other languages and frameworks. Understanding this difference is essential to understanding how to do asynchronous programming with JavaScript.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#callbacks</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/protecting-javascript-microservices-node-js-json-web-tokens-twilio-authy"><div _ngcontent-sc20="" class="date">May 24, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Protecting JavaScript Microservices on Node.js with JSON Web Tokens and Twilio Authy</h3><div _ngcontent-sc20="" class="description"><p>Building a JavaScript application on Node.js with a microservices architecture gives you the ability to scale your app: you can respond to varying load levels by adding and removing instances of a service. When multiple instances of a service access the same data, your application can use a common persistence layer, a database, to share information between instances and maintain consistency between them.</p><p>In many applications you'll also want to limit access to some data and functions to particular users. While you could do this directly in your service APIs, there's a better way.</p><p>This post will show you how to add two-factor authentication (2FA) with Twilio Authy and an authorization web service using JSON Web Tokens (JWTs), a standard for securely storing and transmitting sensitive data.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#microservices</span><span _ngcontent-sc20="" class="ng-star-inserted">#jwt</span><span _ngcontent-sc20="" class="ng-star-inserted">#authorization</span><span _ngcontent-sc20="" class="ng-star-inserted">#authentication</span><span _ngcontent-sc20="" class="ng-star-inserted">#security</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/scale-node-js-javascript-microservices-shared-mongodb-atlas"><div _ngcontent-sc20="" class="date">May 2, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Scaling Node.js JavaScript Microservices on Shared MongoDB Atlas Cloud Persistence Layers</h3><div _ngcontent-sc20="" class="description"><p>Building a JavaScript application on Node.js with a microservices architecture gives you the ability to scale your app to respond to increasing load levels by adding more instances of a service. But when multiple instances of a service work with the same data your application will have an additional design requirement: you'll need a persistence layer the service instances can use to store and share data.</p><p>This post will show you how to use a database as a persistence layer for a JavaScript microservices application. You'll see how the application uses Netflix Eureka and Netflix Zuul for service discovery and load balancing. You'll be able to apply the techniques you learn here to build applications you can scale up and scale out while avoiding the complexity of building service discovery and load balancing on your own.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#microservices</span><span _ngcontent-sc20="" class="ng-star-inserted">#mongodb</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/eureka-zuul-service-discovery-dynamic-routing-javascript-microservices-node-js"><div _ngcontent-sc20="" class="date">Apr 22, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Implementing Eureka and Zuul for Service Discovery and Dynamic Routing in JavaScript Microservices Running on Node.js</h3><div _ngcontent-sc20="" class="description"><p>Building your JavaScript applications as a collection of microservices give you a number of advantages. Your applications can be more modular, uniform, and testable as you build them and they can be more robust, scalable, and available when you deploy them to the production environment. Including a service discovery registry and dynamic routing capabilities will help you achieve scalability and availability in the production.</p><p>This post will show you how to integrate service discovery and intelligent routing into a Node.js application built with a microservices architecture. You'll see how you can do this with two Netflix open source projects, Eureka and Zuul, that run in the Java SE Runtime Environment.</p><p>The Netflix Eureka server provides service discovery. This gives your application's services the ability to find other services without knowing where they are hosted or the full URL required to reach them, so you don't have to provide complete URLs...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#microservices</span><span _ngcontent-sc20="" class="ng-star-inserted">#netflix</span><span _ngcontent-sc20="" class="ng-star-inserted">#eureka</span><span _ngcontent-sc20="" class="ng-star-inserted">#zuul</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/building-javascript-microservices-node-js"><div _ngcontent-sc20="" class="date">Apr 10, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Building JavaScript Microservices with Node.js</h3><div _ngcontent-sc20="" class="description"><p>When your JavaScript application grows in size you start facing challenges with maintaining the code, fixing bugs, and implementing new features. Also, adding new developers to the project becomes complicated.</p><p>Applications are built from pieces, like packages and modules, but at some point those structures aren’t enough to reduce the size and complexity of the application. The idea behind distributed systems is to break big, monolithic designs into small, independent programs which communicate with each other to exchange data and perform operations.</p><p>One of the many variants of distributed systems is the microservices architecture, which structures an application as a collection of loosely coupled services. Services are fine-grained and the communication protocols are lightweight (like the HTTP protocol).</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><span _ngcontent-sc20="" class="ng-star-inserted">#microservices</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/encrypting-cookies-angular-universal-node-js"><div _ngcontent-sc20="" class="date">Mar 13, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Encrypting Cookies with Angular Universal and Node.js</h3><div _ngcontent-sc20="" class="description"><p>Cookies are a ubiquitous feature of web applications, as anyone clicking GDPR notifications for the last several months has realized. Securely handling the data in those cookies is just as much a requirement as the consent notification. Encrypting your Angular and Node.js application cookies is a way to prevent unauthorized access to confidential and personal information, and it’s easy to implement.</p><p>As you know, using an httpOnly cookie helps prevent cross-site scripting (XSS) attacks. (You can learn more in another post.) But what about protecting one registered user’s data against another registered user? Are cookies vulnerable to attacks from trusted users?</p><p>This post will demonstrate how authenticated users can get unauthorized access to other users’ cookie data. It will also show you how to encrypt your cookies so the data can only be read by your code, not by users.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular universal</span><span _ngcontent-sc20="" class="ng-star-inserted">#seo</span><span _ngcontent-sc20="" class="ng-star-inserted">#security</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/expedited-two-factor-authentication-angular-twilio-authy"><div _ngcontent-sc20="" class="date">Feb 27, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Building Expedited Two-Factor Authentication into Angular Apps with Authy</h3><div _ngcontent-sc20="" class="description"><p>Two-Factor Authentication (2FA) provides web applications with an important additional layer of security, but 2FA requires the user to perform an additional action each time they log in. This extra step can be wearying for users who sign into an application frequently. Is it possible to maintain the security provided by a second factor while making an application convenient for repeat visitors? It is with Angular, Node.js, and Twilio Authy.</p><p>Implementing a “remember me” checkbox on the login page is a convenient way for a user to indicate they are going to be a repeat visitor. Behind the scenes, an encrypted security cookie is a convenient mechanism for identifying a user who has previously checked the “remember me” box and logged in successfully from a specific machine.</p><p>With Twilio Authy and an encrypted cookie, such as a JSON Web Token (JWT), you can make the sign-in process fast and...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular universal</span><span _ngcontent-sc20="" class="ng-star-inserted">#seo</span><span _ngcontent-sc20="" class="ng-star-inserted">#security</span><span _ngcontent-sc20="" class="ng-star-inserted">#authentication</span><span _ngcontent-sc20="" class="ng-star-inserted">#2factor</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/transfer-files-data-javascript-applications-angular-node-js"><div _ngcontent-sc20="" class="date">Feb 26, 2019 | for Twilio</div><h3 _ngcontent-sc20="">How to Transfer Files and Data Between Angular Clients and Node.js Backends</h3><div _ngcontent-sc20="" class="description"><p>Having a shared codebase for both the server-side and browser-side code of an Angular application aids the maintainability of a project. You can do that with Angular Universal and Node.js using the server-side rendering (SSR) concept. You can even use SSR to securely pass data, including files, between the application server (Node.js) and the Angular application running on it.</p><p>This post will show you how to create an application for uploading, storing, managing, and downloading files from a Node.js server using a single codebase. When you finish this project you’ll be able to...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular universal</span><span _ngcontent-sc20="" class="ng-star-inserted">#seo</span><span _ngcontent-sc20="" class="ng-star-inserted">#transferstate</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/two-factor-authentication-angular-twilio-authy"><div _ngcontent-sc20="" class="date">Jan 29, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Build Two-factor Authentication in Angular with Twilio Authy</h3><div _ngcontent-sc20="" class="description"><p>User authentication is a crucial requirement for many Angular applications and simply logging in with user ID and password is increasingly inadequate security. Two-Factor Authentication (2FA) provides device-based security that is substantially more difficult to hack, but building your own 2FA system is a daunting challenge. Twilio Authy makes it easy to add 2FA to Angular apps.</p><p>This post will show you how to add Authy to your Angular project. You’ll also learn how to improve the user’s experience and your app’s security by using Angular Universal to implement the login process.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular universal</span><span _ngcontent-sc20="" class="ng-star-inserted">#seo</span><span _ngcontent-sc20="" class="ng-star-inserted">#security</span><span _ngcontent-sc20="" class="ng-star-inserted">#authentication</span><span _ngcontent-sc20="" class="ng-star-inserted">#2factor</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/faster-javascript-web-apps-angular-universal-transferstate-api-watchdog"><div _ngcontent-sc20="" class="date">Jan 2, 2019 | for Twilio</div><h3 _ngcontent-sc20="">Build Faster JavaScript Web Apps with Angular Universal, a TransferState Service and an API Watchdog</h3><div _ngcontent-sc20="" class="description"><p>Search Engine Optimization (SEO) is vital for most web applications. You can build SEO-friendly Angular apps with Angular Universal, but what about the performance and efficiency of such an application? This post will show you how to build fast Angular apps that use client and server resources efficiency while providing server-side rendering (SSR) for SEO purposes.</p><p>In this post we will...</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular universal</span><span _ngcontent-sc20="" class="ng-star-inserted">#performance</span><span _ngcontent-sc20="" class="ng-star-inserted">#transferstate</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/create-search-engine-friendly-internationalized-web-apps-angular-universal-ngx-translate"><div _ngcontent-sc20="" class="date">Dec 14, 2018 | for Twilio</div><h3 _ngcontent-sc20="">How to Create Search Engine-friendly Internationalized Web Apps with Angular Universal and ngx-translate</h3><div _ngcontent-sc20="" class="description"><p>Search Engine Optimization (SEO) is important for many Angular single-page applications (SPAs). You can build SEO-friendly Angular websites with Angular Universal, but how do you make your app SEO-friendly in every language your website supports? Google, Yandex, and Baidu, might request your pages in English, Spanish, Russian, or Chinese: how do you make your server-side rendering return the correct language?</p><p>The answer is ngx-translate, the internationalization (i18n) and localization library for Angular. This module makes it easy to use translation files that provide the correct language for both client-side and server-side rendering. This post will show you how to use it.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular universal</span><span _ngcontent-sc20="" class="ng-star-inserted">#i18n</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/angular-universal-javascript-node-js-aws-lambda"><div _ngcontent-sc20="" class="date">Nov 19, 2018 | for Twilio</div><h3 _ngcontent-sc20="">Getting Started with Serverless Angular Universal on AWS Lambda</h3><div _ngcontent-sc20="" class="description"><p>You can build search-engine optimized (SEO) friendly single page applications (SPA’s) with Angular Universal, a technology that runs your Angular application on the server. And you can reduce the cost of running those applications with AWS Lambda, an event-driven, serverless computing platform provided as a part of Amazon Web Services (AWS). This post will show you how to build and deploy Angular Universal projects on AWS Lambda using Serverless Framework, an open-source command line interface for building and deploying serverless applications.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular universal</span><span _ngcontent-sc20="" class="ng-star-inserted">#serverless</span><span _ngcontent-sc20="" class="ng-star-inserted">#amazon web services</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/prevent-memory-leaks-angular-observable-ngondestroy"><div _ngcontent-sc20="" class="date">Oct 26, 2018 | for Twilio</div><h3 _ngcontent-sc20="">Preventing Memory Leaks in Angular Observables with ngOnDestroy</h3><div _ngcontent-sc20="" class="description"><p>A memory leak is one of the worst types of issues you can have. It’s hard to find, hard to debug, and often hard to solve. Unfortunately, this problem occurs in every programming language or framework, including Angular. Observables are awesome, because of the incessant stream of data, but this benefaction can cause serious problem with memory leak. Today we will take a closer look at the ngOnDestroy Angular hook, and answer the question: “When should I unsubscribe from an observable? What is the best pattern to use?”</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#memory management</span><span _ngcontent-sc20="" class="ng-star-inserted">#best practices</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/2018/05/angular-routing-single-page-applications-javascript-nodejs.html"><div _ngcontent-sc20="" class="date">May 2, 2018 | for Twilio</div><h3 _ngcontent-sc20="">How to Handle Routing in Angular Single Page Applications (SPAs) with JavaScript and Node.js</h3><div _ngcontent-sc20="" class="description"><p>Routing is an essential concept in Single Page Applications (SPA). When your application is divided into separated logical sections, and all of them are under their own URL, your users can easily share links among each other.</p><p>In my previous post, Building an App from Scratch with Angular and Webpack, I covered how to start working with Angular and Webpack. Today we will take a closer look at implementing more components and navigating between them.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/2018/03/building-an-app-from-scratch-with-angular-and-webpack.html"><div _ngcontent-sc20="" class="date">Mar 13, 2018 | for Twilio</div><h3 _ngcontent-sc20="">Building an App from Scratch with Angular and Webpack</h3><div _ngcontent-sc20="" class="description"><p>Using Angular CLI is a popular way of creating Single Page Apps (SPA) with Angular. However, sometimes CLI is not an option for your project or you just want to have better control on what’s going on behind the scenes. Let’s take a look at how we can create an Angular project entirely from scratch.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/2017/10/serverless-framework-plugin-aws-lambda-javascript.html"><div _ngcontent-sc20="" class="date">Oct 26, 2017 | for Twilio</div><h3 _ngcontent-sc20="">How to Write Your Own Serverless Framework Plugin for AWS Lambda using JavaScript</h3><div _ngcontent-sc20="" class="description"><p>The Serverless framework makes it easy to deploy applications to AWS Lambda. However, Serverless does not currently support binary files, but we can solve this issue by implementing a Serverless plugin and uploading proper configuration to the AWS API Gateway.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#serverless</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><!----></div></div><div _ngcontent-sc20="" class="entry ng-star-inserted"><a _ngcontent-sc20="" href="https://www.twilio.com/blog/2017/09/serverless-deploy-nodejs-application-on-faas-without-pain.html"><div _ngcontent-sc20="" class="date">Sep 14, 2017 | for Twilio</div><h3 _ngcontent-sc20="">How to Deploy JavaScript &amp; Node.js Applications to AWS Lambda</h3><div _ngcontent-sc20="" class="description"><p>Functions-as-a-Service (FaaS) such as Amazon Web Services Lambda and Twilio Functions can be cheap execution environments in which you pay only for resources used to deal with a particular request, typically measured in seconds or milliseconds.</p><p>Today we will take a look at deploying a JavaScript Node.js application to AWS Lambda. Our application will keep a list of our best friends which we would like to invite for a birthday party.</p></div></a><div _ngcontent-sc20="" class="keywords"><span _ngcontent-sc20="" class="ng-star-inserted">#angular</span><span _ngcontent-sc20="" class="ng-star-inserted">#angular universal</span><span _ngcontent-sc20="" class="ng-star-inserted">#amazon web services</span><span _ngcontent-sc20="" class="ng-star-inserted">#javascript</span><span _ngcontent-sc20="" class="ng-star-inserted">#serverless</span><span _ngcontent-sc20="" class="ng-star-inserted">#nodejs</span><!----></div></div><!----></app-writing><!----></div><app-footer _ngcontent-sc22="" class="ng-tns-c22-0 ng-tns-c21-1" _nghost-sc21=""><div _ngcontent-sc21="" class="contact-info ng-tns-c21-1"><div _ngcontent-sc21="" class="ng-tns-c21-1">Reach me via&nbsp;</div><div _ngcontent-sc21="" class="ng-tns-c21-1"><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">Twitter: @maciejtreder</span><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">StackOverflow: @maciejtreder</span><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">LinkedIn: @maciejtreder</span><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">NPM: @maciejtreder</span><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">GitHub: @maciejtreder</span><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">GitLab: @maciejtreder</span><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">Email: contact@maciejtreder</span><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">Skype: @maciejtreder</span><span _ngcontent-sc21="" class="ng-tns-c21-1 ng-trigger ng-trigger-state" style="display:none;">Phone: +1 646-397-4810</span></div></div><div _ngcontent-sc21="" class="social ng-tns-c21-1"><a _ngcontent-sc21="" name="twitter" href="https://twitter.com/maciejtreder" rel="noopener" target="_blank" class="twitter ng-tns-c21-1"></a><a _ngcontent-sc21="" name="stackoverflow" href="https://stackoverflow.com/users/2849613/maciej-treder" rel="noopener" target="_blank" class="stackoverflow ng-tns-c21-1"></a><a _ngcontent-sc21="" name="linkedin" href="https://www.linkedin.com/in/maciej-treder" rel="nopener" target="_blank" class="linkedin ng-tns-c21-1"></a><a _ngcontent-sc21="" name="npm" href="https://www.npmjs.com/~maciejtreder" rel="nopener" target="_blank" class="npm ng-tns-c21-1"></a><a _ngcontent-sc21="" name="github" href="https://github.com/maciejtreder" rel="noopener" target="_blank" class="github ng-tns-c21-1"></a><a _ngcontent-sc21="" name="gitlab" href="https://gitlab.com/maciejtreder" rel="noopener" target="_blank" class="gitlab ng-tns-c21-1"></a><a _ngcontent-sc21="" name="email" href="mailto: contact@maciejtreder.com" class="mail ng-tns-c21-1"></a><a _ngcontent-sc21="" name="skype" href="skype:live:maciejtreder?call" class="skype ng-tns-c21-1"></a><a _ngcontent-sc21="" name="phone" href="tel:+16463974810" class="phone ng-tns-c21-1"></a></div><div _ngcontent-sc21="" class="instructions ng-tns-c21-1">click to freeze; double-click to follow</div></app-footer><div _ngcontent-sc22="" class="outer ng-tns-c22-0"><span _ngcontent-sc22="" class="ng-tns-c22-0 ng-trigger ng-trigger-state" style="opacity:0;z-index:-1;">&nbsp;</span></div></app-root>
<script src="runtime.e227d1a0e31cbccbf8ec.js" defer=""></script><script src="polyfills.a4021de53358bb0fec14.js" defer=""></script><script src="main.508083cc4d3059ff840c.js" defer=""></script>

<script id="serverApp-state" type="application/json">{&q;posts&q;:[{&q;title&q;:&q;Asynchronous JavaScript: Choosing the Right Asynchronous Tool&q;,&q;description&q;:&q;&l;p&g;Since its beginning as a primitive, unstandardized scripting language for web browsers, JavaScript has gained many features that better equip it for handling common programming tasks. Some of the most important improvements are in the area of handling asynchronous events like form submission, user interface interaction, and media management.&l;/p&g;&l;p&g;The growth of server-side JavaScript enabled by Node.js has substantially expanded the range of project types and business challenges JavaScript can successfully address, adding new requirements for asynchronous processing. The popularity of web services as a design paradigm and REST APIs as an interaction standard have both added to the scope of asynchronous tasks for the language.&l;/p&g;&l;p&g;The Node package management system, npm, makes it possible to easily integrate capabilities provided in open source libraries. Packages for asynchronous tasks have been some of the most successful of these, adding programming paradigms to JavaScript that were unimagined in the early days of...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-choosing-the-right-asynchronous-tool&q;,&q;date&q;:&q;2020-08-27T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Using Promises With REST APIs in Node.js&q;,&q;description&q;:&q;&l;p&g;In JavaScript, like many programming languages, asynchronous processing can be used to handle tasks that take a long time to run or are potentially unresponsive. The JavaScript Promise object provides a way of monitoring their state and serves as a placeholder and container for the data they’ll eventually return — or not.&l;/p&g;&l;p&g;Often it doesn’t matter when a Promise returns data and the members of a collection of Promises can be resolved independently without regard to timing. A function can perform asynchronous tasks that don’t depend on the data from, or the success of, other asynchronous tasks.&l;/p&g;&l;p&g;But sometimes business rules or program design require that asynchronous actions are dependent on other asynchronous operations. For example...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-using-promises-rest-apis-nodejs&q;,&q;date&q;:&q;2020-07-30T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Introducing async and await&q;,&q;description&q;:&q;&l;p&g;Asynchronous processing is one of the most important aspects of the JavaScript language. JavaScript is a single-threaded language, so it needs a mechanism to deal with the actions like performing time-intensive and potentially unreliable activities like making REST API calls, reading files from the disk, or interacting with user input.&l;/p&g;&l;p&g;In JavaScript the mechanism used is an event loop, which processes a callback queue in order from oldest item to newest. Each item in the queue is a message that’s processed completely before moving on to the next next message. Each message is a function that returns a response to code elsewhere in the application. Functions used in this way are called callback functions.&l;/p&g;&l;p&g;Because of callbacks, JavaScript can use a number of techniques for getting around its single-threaded nature to implement asynchronous processing. Unfortunately, some of those techniques, JavaScript Promises and RxJS Observables, force you to introduce at...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-introducing-async-and-await&q;,&q;date&q;:&q;2020-07-01T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Tracking the ISS with Real-Time Event Notifications Using Node.js, RxJS Observables, and Twilio Programmable SMS&q;,&q;description&q;:&q;&l;p&g;Are you a developer looking for a new hobby that’s compatible with sheltering in place? Would you like to be able to share it with friends from a virus-safe distance?&l;/p&g;&l;p&g;You can stargaze from the safety of your own lawn, balcony, or roof, and you don’t need any equipment other than your own eyes, and maybe a pair of binoculars. There are plenty of bright objects in the night sky that are visible with the naked eye. One of them is the International Space Station (ISS), which is the third brightest object in the sky after the sun and moon.&l;/p&g;&l;p&g;The ISS whips around the earth at 27,576 kilometers per hour (17,000 miles per hour), making a complete orbit every 94 minutes. Opportunities to observe it only last a few minutes, so it’s helpful to know when the ISS will be visible and from which direction it will appear.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/real-time-event-notifications-using-node-js-rxjs-observables-twilio-programmable-sms&q;,&q;date&q;:&q;2020-05-22T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;rxjs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Confirming SMS Message Delivery with RxJS Observables, Node.js, and Twilio Programmable SMS&q;,&q;description&q;:&q;&l;p&g;SMS messages can reach over 4.5 billion text-enabled devices to notify people about upcoming appointments, emergencies, traffic disruptions, or commercial promotions. Sending SMS messages programmatically enables you to reach many people almost simultaneously. With Twilio Programmable SMS you can create a Node.js application that sends many messages and reports when each of them has been delivered—or not.&l;/p&g;&l;p&g;Twilio Programmable SMS includes a helper library for Node.js that makes it easy to interact with the SMS API without having to create and manipulate connections to the API endpoints. Once an SMS message request is created with the helper library its status is emitted as a JavaScript Promise. While that is great for creating a request asynchronously, Promises only resolve once, and the message request will pass through more than one state as it makes its way—or not—to the recipient.&l;/p&g;&l;p&g;You can create a mechanism for monitoring and reporting the status...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/confirming-sms-message-delivery-with-rxjs-observables-node-js-and-twilio-programmable-sms&q;,&q;date&q;:&q;2020-04-09T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;rxjs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Using RxJS Observables with REST APIs in Node.js&q;,&q;description&q;:&q;&l;p&g;ReactiveX is an electrifying programming concept. It’s widely adopted in popular programming languages, including JavaScript. ReactiveX programs can react to data as it is emitted from a source, rather than get the data from it. This is a convenient way of handling data from sources like web APIs or WebSockets.&l;/p&g;&l;p&g;In this post you’ll get hands-on experience doing ReactiveX programming with RxJS: ReactiveX for JavaScript. You’ll learn how to perform REST API calls to retrieve data asynchronously, manipulate it as it arrives, and perform subsequent calls based on the emitted data. You’ll also see how to perform other actions whenever data is emitted by an Observable.&l;/p&g;&l;p&g;This post focuses on how to utilize RxJS Observables with REST API calls...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/async-js-rxjs-observables-rest-api-nodejs&q;,&q;date&q;:&q;2020-01-27T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;rxjs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Introducing ReactiveX and RxJS Observables&q;,&q;description&q;:&q;&l;p&g;Reactive Extensions (ReactiveX) are one of the most widely-adopted set of tools in programming today. ReactiveX libraries for JavaScript and other languages provide a way to operate on sequences of data as if they were events. This is a convenient way to handle data from asynchronous sources like web APIs: your programs can react to data as it is emitted from the source without tightly coupling the code that uses the data with the code that gets the data.&l;/p&g;&l;p&g;In this post you’ll learn about the fundamental concepts of ReactiveX programming and get hands-on experience doing ReactiveX programming with RxJS for JavaScript. You’ll learn how to retrieve data asynchronously, manipulate it as it arrives, and handle errors. You’ll also see how RxJS Observables compare to JavaScript Promises.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-reactivex-rxjs-observables-nodejs&q;,&q;date&q;:&q;2019-10-31T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;rxjs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Refactoring Callbacks to Promises in Node.js&q;,&q;description&q;:&q;&l;p&g;If you know how the event loop mechanism works in JavaScript you know how it enables you to work with asynchronous events. You might also know how to refactor your code into separate functions to reduce the amount of nesting associated with a sequence of callback functions. If you work with web APIs you are probably familiar with the JavaScript request library, which is used to perform HTTP calls.&l;/p&g;&l;p&g;You can put these skills together to retrieve remote data through an HTTP request and work with the call response asynchronously. But in doing so you’ll probably notice that code has at least one pitfall: the logical order of declared functions is reversed. That makes the code hard to read and maintain.&l;/p&g;&l;p&g;With the node-fetch JavaScript library and Promise objects you can reduce nesting, known as the callback “Pyramid of Doom”, and organize your code in a more readable and logical&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-refactor-callbacks-promises-node-js&q;,&q;date&q;:&q;2019-10-14T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;rxjs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Advanced Promises with Node.js&q;,&q;description&q;:&q;&l;p&g;JavaScript Promise objects are a considerable improvement over basic JavaScript callback functions. Promises provide an object that represents both the state of an asynchronous function and the values returned by it. The state indicates whether the promise is pending, fulfilled by a successfully completed operation, or rejected because of an error or other condition. When a promise is fulfilled its value is determined by the asynchronous operation executed by the promise.&l;/p&g;&l;p&g;Promises can also be chained together to use the state of settled promises (resolved or rejected) and the promises’ values to control the flow of execution in your program. This is useful when you have a sequence of asynchronous operations to perform that each depend on the results of the previous operation: the next step in the chain isn’t performed until the preceding step is resolved. Chains of promises also include error propagation; errors in a...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-advanced-promises-chaining-collections-nodejs&q;,&q;date&q;:&q;2019-10-10T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;promises&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Introduction to JavaScript Promises&q;,&q;description&q;:&q;&l;p&g;Asynchronous processing is one of the most important capabilities JavaScript acquired as the language matured. JavaScript’s async capabilities enable more sophisticated and responsive user interfaces. They also make it possible to implement a distributed web application architecture built on standards like SOAP and REST.&l;/p&g;&l;p&g;JavaScript Promises are currently the most powerful and flexible asynchronous technology built into the language itself. This post will explain how they work and get you writing your own promises with some practical examples.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-introduction-promises&q;,&q;date&q;:&q;2019-08-31T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;promises&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Organizing Callbacks for Readability and Reusability&q;,&q;description&q;:&q;&l;p&g;Asynchronous programming is an essential part of being a complete JavaScript programmer. Understanding the code execution flow in JavaScript is the foundation of understanding how it can handle asynchronous tasks. And being able to program asynchronous tasks enables you to take advantage of the extensive array of functions provided by JavaScript runtime engines and external APIs. With those tools you can connect your JavaScript programs with web APIs across the internet and effectively manage those—sometimes tenuous—connections.&l;/p&g;&l;p&g;With power comes complexity. Using JavaScript callbacks to implement asynchronous functionality can quickly create a series of deeply nested function calls. This post will show you how to write and organize your JavaScript callbacks to maximize the readability, maintainability, and reusability of your asynchronous functions.&l;/p&g;&l;p&g;As an old programming saying goes:&l;/p&g;&l;p&g;\&q;Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\&q;&l;/p&g;&l;p&g;The first part of this...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-organize-callbacks-readability-reusability&q;,&q;date&q;:&q;2019-06-28T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;callbacks&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Asynchronous JavaScript: Understanding Callbacks&q;,&q;description&q;:&q;&l;p&g;By design, JavaScript is a synchronous scripting language. In fact, many of the widely used asynchronous functions in JavaScript are not part of the core language. Understanding how asynchronous features work in the JavaScript ecosystem, including the role played by external APIs, is an essential part of using the language effectively.&l;/p&g;&l;p&g;This post will show you how to use asynchronous functionality in JavaScript. It’s also going to explain an important difference between the way code execution works in JavaScript and other languages and frameworks. Understanding this difference is essential to understanding how to do asynchronous programming with JavaScript.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/asynchronous-javascript-understanding-callbacks&q;,&q;date&q;:&q;2019-06-28T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;callbacks&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Protecting JavaScript Microservices on Node.js with JSON Web Tokens and Twilio Authy&q;,&q;description&q;:&q;&l;p&g;Building a JavaScript application on Node.js with a microservices architecture gives you the ability to scale your app: you can respond to varying load levels by adding and removing instances of a service. When multiple instances of a service access the same data, your application can use a common persistence layer, a database, to share information between instances and maintain consistency between them.&l;/p&g;&l;p&g;In many applications you&s;ll also want to limit access to some data and functions to particular users. While you could do this directly in your service APIs, there&s;s a better way.&l;/p&g;&l;p&g;This post will show you how to add two-factor authentication (2FA) with Twilio Authy and an authorization web service using JSON Web Tokens (JWTs), a standard for securely storing and transmitting sensitive data.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/protecting-javascript-microservices-node-js-json-web-tokens-twilio-authy&q;,&q;date&q;:&q;2019-05-24T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;microservices&q;,&q;jwt&q;,&q;authorization&q;,&q;authentication&q;,&q;security&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Scaling Node.js JavaScript Microservices on Shared MongoDB Atlas Cloud Persistence Layers&q;,&q;description&q;:&q;&l;p&g;Building a JavaScript application on Node.js with a microservices architecture gives you the ability to scale your app to respond to increasing load levels by adding more instances of a service. But when multiple instances of a service work with the same data your application will have an additional design requirement: you&s;ll need a persistence layer the service instances can use to store and share data.&l;/p&g;&l;p&g;This post will show you how to use a database as a persistence layer for a JavaScript microservices application. You&s;ll see how the application uses Netflix Eureka and Netflix Zuul for service discovery and load balancing. You&s;ll be able to apply the techniques you learn here to build applications you can scale up and scale out while avoiding the complexity of building service discovery and load balancing on your own.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/scale-node-js-javascript-microservices-shared-mongodb-atlas&q;,&q;date&q;:&q;2019-05-02T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;microservices&q;,&q;mongodb&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Implementing Eureka and Zuul for Service Discovery and Dynamic Routing in JavaScript Microservices Running on Node.js&q;,&q;description&q;:&q;&l;p&g;Building your JavaScript applications as a collection of microservices give you a number of advantages. Your applications can be more modular, uniform, and testable as you build them and they can be more robust, scalable, and available when you deploy them to the production environment. Including a service discovery registry and dynamic routing capabilities will help you achieve scalability and availability in the production.&l;/p&g;&l;p&g;This post will show you how to integrate service discovery and intelligent routing into a Node.js application built with a microservices architecture. You&s;ll see how you can do this with two Netflix open source projects, Eureka and Zuul, that run in the Java SE Runtime Environment.&l;/p&g;&l;p&g;The Netflix Eureka server provides service discovery. This gives your application&s;s services the ability to find other services without knowing where they are hosted or the full URL required to reach them, so you don&s;t have to provide complete URLs...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/eureka-zuul-service-discovery-dynamic-routing-javascript-microservices-node-js&q;,&q;date&q;:&q;2019-04-22T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;microservices&q;,&q;netflix&q;,&q;eureka&q;,&q;zuul&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Building JavaScript Microservices with Node.js&q;,&q;description&q;:&q;&l;p&g;When your JavaScript application grows in size you start facing challenges with maintaining the code, fixing bugs, and implementing new features. Also, adding new developers to the project becomes complicated.&l;/p&g;&l;p&g;Applications are built from pieces, like packages and modules, but at some point those structures aren’t enough to reduce the size and complexity of the application. The idea behind distributed systems is to break big, monolithic designs into small, independent programs which communicate with each other to exchange data and perform operations.&l;/p&g;&l;p&g;One of the many variants of distributed systems is the microservices architecture, which structures an application as a collection of loosely coupled services. Services are fine-grained and the communication protocols are lightweight (like the HTTP protocol).&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/building-javascript-microservices-node-js&q;,&q;date&q;:&q;2019-04-10T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;nodejs&q;,&q;microservices&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Encrypting Cookies with Angular Universal and Node.js&q;,&q;description&q;:&q;&l;p&g;Cookies are a ubiquitous feature of web applications, as anyone clicking GDPR notifications for the last several months has realized. Securely handling the data in those cookies is just as much a requirement as the consent notification. Encrypting your Angular and Node.js application cookies is a way to prevent unauthorized access to confidential and personal information, and it’s easy to implement.&l;/p&g;&l;p&g;As you know, using an httpOnly cookie helps prevent cross-site scripting (XSS) attacks. (You can learn more in another post.) But what about protecting one registered user’s data against another registered user? Are cookies vulnerable to attacks from trusted users?&l;/p&g;&l;p&g;This post will demonstrate how authenticated users can get unauthorized access to other users’ cookie data. It will also show you how to encrypt your cookies so the data can only be read by your code, not by users.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/encrypting-cookies-angular-universal-node-js&q;,&q;date&q;:&q;2019-03-13T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;,&q;angular universal&q;,&q;seo&q;,&q;security&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Building Expedited Two-Factor Authentication into Angular Apps with Authy&q;,&q;description&q;:&q;&l;p&g;Two-Factor Authentication (2FA) provides web applications with an important additional layer of security, but 2FA requires the user to perform an additional action each time they log in. This extra step can be wearying for users who sign into an application frequently. Is it possible to maintain the security provided by a second factor while making an application convenient for repeat visitors? It is with Angular, Node.js, and Twilio Authy.&l;/p&g;&l;p&g;Implementing a “remember me” checkbox on the login page is a convenient way for a user to indicate they are going to be a repeat visitor. Behind the scenes, an encrypted security cookie is a convenient mechanism for identifying a user who has previously checked the “remember me” box and logged in successfully from a specific machine.&l;/p&g;&l;p&g;With Twilio Authy and an encrypted cookie, such as a JSON Web Token (JWT), you can make the sign-in process fast and...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/expedited-two-factor-authentication-angular-twilio-authy&q;,&q;date&q;:&q;2019-02-27T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;,&q;angular universal&q;,&q;seo&q;,&q;security&q;,&q;authentication&q;,&q;2factor&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;How to Transfer Files and Data Between Angular Clients and Node.js Backends&q;,&q;description&q;:&q;&l;p&g;Having a shared codebase for both the server-side and browser-side code of an Angular application aids the maintainability of a project. You can do that with Angular Universal and Node.js using the server-side rendering (SSR) concept. You can even use SSR to securely pass data, including files, between the application server (Node.js) and the Angular application running on it.&l;/p&g;&l;p&g;This post will show you how to create an application for uploading, storing, managing, and downloading files from a Node.js server using a single codebase. When you finish this project you’ll be able to...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/transfer-files-data-javascript-applications-angular-node-js&q;,&q;date&q;:&q;2019-02-26T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;,&q;angular universal&q;,&q;seo&q;,&q;transferstate&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Build Two-factor Authentication in Angular with Twilio Authy&q;,&q;description&q;:&q;&l;p&g;User authentication is a crucial requirement for many Angular applications and simply logging in with user ID and password is increasingly inadequate security. Two-Factor Authentication (2FA) provides device-based security that is substantially more difficult to hack, but building your own 2FA system is a daunting challenge. Twilio Authy makes it easy to add 2FA to Angular apps.&l;/p&g;&l;p&g;This post will show you how to add Authy to your Angular project. You’ll also learn how to improve the user’s experience and your app’s security by using Angular Universal to implement the login process.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/two-factor-authentication-angular-twilio-authy&q;,&q;date&q;:&q;2019-01-29T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;,&q;angular universal&q;,&q;seo&q;,&q;security&q;,&q;authentication&q;,&q;2factor&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Build Faster JavaScript Web Apps with Angular Universal, a TransferState Service and an API Watchdog&q;,&q;description&q;:&q;&l;p&g;Search Engine Optimization (SEO) is vital for most web applications. You can build SEO-friendly Angular apps with Angular Universal, but what about the performance and efficiency of such an application? This post will show you how to build fast Angular apps that use client and server resources efficiency while providing server-side rendering (SSR) for SEO purposes.&l;/p&g;&l;p&g;In this post we will...&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/faster-javascript-web-apps-angular-universal-transferstate-api-watchdog&q;,&q;date&q;:&q;2019-01-02T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;,&q;angular universal&q;,&q;performance&q;,&q;transferstate&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;How to Create Search Engine-friendly Internationalized Web Apps with Angular Universal and ngx-translate&q;,&q;description&q;:&q;&l;p&g;Search Engine Optimization (SEO) is important for many Angular single-page applications (SPAs). You can build SEO-friendly Angular websites with Angular Universal, but how do you make your app SEO-friendly in every language your website supports? Google, Yandex, and Baidu, might request your pages in English, Spanish, Russian, or Chinese: how do you make your server-side rendering return the correct language?&l;/p&g;&l;p&g;The answer is ngx-translate, the internationalization (i18n) and localization library for Angular. This module makes it easy to use translation files that provide the correct language for both client-side and server-side rendering. This post will show you how to use it.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/create-search-engine-friendly-internationalized-web-apps-angular-universal-ngx-translate&q;,&q;date&q;:&q;2018-12-14T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;,&q;angular universal&q;,&q;i18n&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Getting Started with Serverless Angular Universal on AWS Lambda&q;,&q;description&q;:&q;&l;p&g;You can build search-engine optimized (SEO) friendly single page applications (SPA’s) with Angular Universal, a technology that runs your Angular application on the server. And you can reduce the cost of running those applications with AWS Lambda, an event-driven, serverless computing platform provided as a part of Amazon Web Services (AWS). This post will show you how to build and deploy Angular Universal projects on AWS Lambda using Serverless Framework, an open-source command line interface for building and deploying serverless applications.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/angular-universal-javascript-node-js-aws-lambda&q;,&q;date&q;:&q;2018-11-19T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;,&q;angular universal&q;,&q;serverless&q;,&q;amazon web services&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Preventing Memory Leaks in Angular Observables with ngOnDestroy&q;,&q;description&q;:&q;&l;p&g;A memory leak is one of the worst types of issues you can have. It’s hard to find, hard to debug, and often hard to solve. Unfortunately, this problem occurs in every programming language or framework, including Angular. Observables are awesome, because of the incessant stream of data, but this benefaction can cause serious problem with memory leak. Today we will take a closer look at the ngOnDestroy Angular hook, and answer the question: “When should I unsubscribe from an observable? What is the best pattern to use?”&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/prevent-memory-leaks-angular-observable-ngondestroy&q;,&q;date&q;:&q;2018-10-26T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;,&q;memory management&q;,&q;best practices&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;How to Handle Routing in Angular Single Page Applications (SPAs) with JavaScript and Node.js&q;,&q;description&q;:&q;&l;p&g;Routing is an essential concept in Single Page Applications (SPA). When your application is divided into separated logical sections, and all of them are under their own URL, your users can easily share links among each other.&l;/p&g;&l;p&g;In my previous post, Building an App from Scratch with Angular and Webpack, I covered how to start working with Angular and Webpack. Today we will take a closer look at implementing more components and navigating between them.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/2018/05/angular-routing-single-page-applications-javascript-nodejs.html&q;,&q;date&q;:&q;2018-05-02T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;Building an App from Scratch with Angular and Webpack&q;,&q;description&q;:&q;&l;p&g;Using Angular CLI is a popular way of creating Single Page Apps (SPA) with Angular. However, sometimes CLI is not an option for your project or you just want to have better control on what’s going on behind the scenes. Let’s take a look at how we can create an Angular project entirely from scratch.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/2018/03/building-an-app-from-scratch-with-angular-and-webpack.html&q;,&q;date&q;:&q;2018-03-13T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;angular&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;How to Write Your Own Serverless Framework Plugin for AWS Lambda using JavaScript&q;,&q;description&q;:&q;&l;p&g;The Serverless framework makes it easy to deploy applications to AWS Lambda. However, Serverless does not currently support binary files, but we can solve this issue by implementing a Serverless plugin and uploading proper configuration to the AWS API Gateway.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/2017/10/serverless-framework-plugin-aws-lambda-javascript.html&q;,&q;date&q;:&q;2017-10-26T00:00:00.000Z&q;,&q;keywords&q;:[&q;javascript&q;,&q;serverless&q;,&q;nodejs&q;],&q;for&q;:&q;Twilio&q;},{&q;title&q;:&q;How to Deploy JavaScript &a; Node.js Applications to AWS Lambda&q;,&q;description&q;:&q;&l;p&g;Functions-as-a-Service (FaaS) such as Amazon Web Services Lambda and Twilio Functions can be cheap execution environments in which you pay only for resources used to deal with a particular request, typically measured in seconds or milliseconds.&l;/p&g;&l;p&g;Today we will take a look at deploying a JavaScript Node.js application to AWS Lambda. Our application will keep a list of our best friends which we would like to invite for a birthday party.&l;/p&g;&q;,&q;url&q;:&q;https://www.twilio.com/blog/2017/09/serverless-deploy-nodejs-application-on-faas-without-pain.html&q;,&q;date&q;:&q;2017-09-14T00:00:00.000Z&q;,&q;keywords&q;:[&q;angular&q;,&q;angular universal&q;,&q;amazon web services&q;,&q;javascript&q;,&q;serverless&q;,&q;nodejs&q;],&q;for&q;:&q;Twilio&q;}]}</script></body></html><!-- This page was prerendered with Angular Universal -->